<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singularität: 2030 - Das Ende des Lernens</title>
    <style>
        /* CSS - Unverändert bis auf Ergänzungen für Title Card */
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; color: #fff; background-color: #000; }
        #container { position: absolute; width: 100%; height: 100%; }
        #title-card { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; opacity: 1; transition: opacity 2s ease-in-out 3s; color: #ccc; font-family: 'Consolas', 'Courier New', monospace; }
        #title-card h1 { font-size: 2.5em; color: #ff3030; text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; max-width: 80%; text-align: center; margin: 0; }
        #title-card p { font-size: 1.1em; max-width: 70%; text-align: center; margin-top: 25px; line-height: 1.6; color: #a0a0a0; }

        /* NEU: Stile für Ladebalken und Credits */
        #loading-container {
            width: 300px; /* Breite des Ladebalkens */
            height: 15px;
            border: 1px solid #555;
            margin-top: 40px; /* Abstand nach oben */
            background-color: #1a1a1a;
            overflow: hidden; /* Verhindert Überlaufen der inneren Leiste */
        }
        #loading-bar {
            width: 0%; /* Startet bei 0 Breite */
            height: 100%;
            background-color: #00aaff; /* Farbe des Balkens */
            transition: width 4.5s linear; /* Animation über 4.5s, endet kurz vor Fade-Out */
        }
        #credits {
            font-size: 0.8em;
            color: #666; /* Dezente Farbe */
            margin-top: 20px; /* Abstand zum Ladebalken */
        }
        /* Ende NEU */

        #escape-prompt, #end-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: none; flex-direction: column; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box; text-align: center; z-index: 110; }
        #escape-prompt h2, #end-screen h1 { margin-bottom: 30px; color: #ff3030; text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
        #end-screen h1 { color: #00ff00; text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; }
        #escape-prompt p, #end-screen p { font-size: 1.1em; max-width: 800px; margin: 15px 0; line-height: 1.6; color: #ccc; }
        #end-screen p { font-size: 1.3em; color: #00e0ff; }
        #escape-prompt button { margin-top: 40px; padding: 15px 30px; font-size: 1.2em; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s, transform 0.2s; text-transform: uppercase; }
        #escape-prompt .button-container { display: flex; gap: 30px; margin-top: 30px; }
        #escape-yes { background-color: #00aa00; box-shadow: 0 0 15px rgba(0, 255, 0, 0.6); }
        #escape-yes:hover { background-color: #008800; transform: scale(1.05); }
        #escape-no { background-color: #aa0000; box-shadow: 0 0 15px rgba(255, 0, 0, 0.6); }
        #escape-no:hover { background-color: #880000; transform: scale(1.05); }
        #hud, #scanner, #controls, #message { background-color: rgba(10, 10, 20, 0.7); border: 1px solid rgba(0, 170, 255, 0.4); box-shadow: 0 0 10px rgba(0, 170, 255, 0.3); font-family: 'Consolas', 'Courier New', monospace; color: #00e0ff; padding: 15px; border-radius: 3px; z-index: 10; }
        #hud { position: absolute; top: 20px; left: 20px; }
        #hud div { margin-bottom: 5px; }
        #anomalies-found { font-weight: bold; color: #ffff00; }
        #scanner { position: absolute; bottom: 20px; right: 20px; width: 300px; }
        #scan-results span { font-weight: bold; }
        #scan-results .cryptic { color: #ff6600; font-style: italic; }
        #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; max-width: 80%; display: none; z-index: 20; }
        #message h2 { color: #ff3030; margin-top: 0; text-shadow: 0 0 8px #ff0000; }
        #message p { color: #ccc; }
        #message button { margin-top: 20px; padding: 10px 20px; font-size: 1em; background-color: #00aaff; color: white; border: none; border-radius: 3px; cursor: pointer; transition: background-color 0.3s; box-shadow: 0 0 10px rgba(0, 170, 255, 0.5); }
        #message button:hover { background-color: #0077cc; }
        #controls { position: absolute; bottom: 20px; left: 20px; display: none; /* Initial versteckt */ }
        #controls div { margin-bottom: 3px; }
        #debug-controls { margin-top: 10px; font-size: 11px; color: #aaa; }
    </style>
</head>
<body>
    <!-- Title Card HTML erweitert -->
    <div id="title-card">
        <h1>Singularity 2030: Als wir vergassen wie man lernt</h1>
        <p>2030 - die Singularität ist eingetreten und eine unheilvolle KI hat die Macht übernommen, weil wir verlernt haben zu lernen - mit furchtbaren Folgen. Finde raus, was passiert ist und suche nach in der Welt verteilten Anomalien, die aufzeigen, auf was wir heute achten müssen, damit wir nicht in dieser Dystopie enden.</p>
        <!-- NEU: Ladebalken -->
        <div id="loading-container">
            <div id="loading-bar"></div>
        </div>
        <!-- NEU: Credits -->
        <p id="credits">Workshop PICTS: Formative Tests - erstellt von Claude AI, Google Gemini und Udio 2025</p>
    </div>

    <!-- Spiel Container & UI Elemente (unverändert) -->
    <div id="container"></div>
    <div id="hud">
        <div>ALTITUDE: <span id="altitude">0</span> m</div>
        <div>VELOCITY: <span id="speed">0</span> km/h</div>
        <div>GRID REF: <span id="coordinates">0, 0</span></div>
        <div id="anomalies-found">ANOMALIEN GEFUNDEN: 0 / 15</div>
    </div>
    <div id="scanner">
        <div>ANOMALY SCANNER v2.1</div>
        <div id="scan-results">SYSTEM NOMINAL :: NO ANOMALIES DETECTED</div>
    </div>
    <div id="controls">
        <div>STEUERUNG:</div>
        <div>W/↑: BESCHLEUNIGEN</div>
        <div>S/↓: VERLANGSAMEN</div>
        <div>A/←: GIEREN LINKS</div>
        <div>D/→: GIEREN RECHTS</div>
        <div>Q: AUFSTEIGEN</div>
        <div>E: ABSINKEN</div>
        <div>SPACE: PAUSE / INTERAGIEREN</div>
        <div id="debug-controls"></div>
    </div>
    <div id="message">
        <h2>SYSTEM ALERT</h2>
        <p id="message-content"></p>
        <button id="close-message">CLOSE TRANSMISSION</button>
    </div>
    <div id="escape-prompt">
        <h2>Weg zur Freiheit?</h2>
        <p>Sie haben genügend Anomalien (10/15) entdeckt, um Muster im Nexus zu erkennen und vielleicht einen Weg aus dieser Dystopie zu finden. Wollen Sie die Suche beenden und die Flucht versuchen, oder weiter nach den verbleibenden Fragmenten suchen?</p>
        <div class="button-container">
            <button id="escape-yes">Weiter suchen (Ja)</button>
            <button id="escape-no">Flucht versuchen (Nein)</button>
        </div>
    </div>
    <!-- End Screen HTML geändert -->
    <div id="end-screen">
        <h1>Erkenntnis Gewonnen</h1>
        <!-- GEÄNDERT: Neuer Endtext -->
        <p>Basierend auf den gesammelten Daten können wir heute den Unterricht anders gestalten und die Dystopie verhindern.</p>
        <p>Gesamte Suchzeit: <span id="end-time">0</span> Sekunden.</p>
        <p>(Aktualisieren Sie die Seite, um neu zu beginnen)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Hauptvariablen (unverändert)
        let scene, camera, renderer, aircraft, skyBox;
        let clock = new THREE.Clock();
        let pause = false;
        let speed = 50;
        let maxSpeed = 500;
        let acceleration = 2;
        let deceleration = 0.2;
        let velocity = new THREE.Vector3(0, 0, 0);
        let position = new THREE.Vector3(0, 550, 250);
        let rotation = new THREE.Euler(0, 0, 0, 'YXZ');
        let direction = new THREE.Vector3(0, 0, 1);
        let buildings = [];
        let anomalies = [];
        let currentRoll = 0;
        let maxRoll = Math.PI / 4;
        let rollSpeed = 0.05;
        let keys = { forward: false, backward: false, left: false, right: false, up: false, down: false };
        let foundAnomalies = new Set();
        let escapePromptShown = false;
        let animationFrameId;
        let lastScanMessageTime = 0;

        // Audio Setup (unverändert von letzter Version)
        const introSound = new Audio('intro_sound.mp3');
        introSound.preload = 'auto';
        const gameSound1 = new Audio('gamesound1.mp3');
        gameSound1.preload = 'auto';
        let soundPlayed = false;
        let gameSound1Played = false;
        let gameSoundTimeoutId = null;
        introSound.onended = () => {
            if (!gameSound1Played) {
                if (gameSoundTimeoutId) { clearTimeout(gameSoundTimeoutId); }
                gameSoundTimeoutId = setTimeout(() => {
                    gameSound1.play().catch(e => console.error("Game sound 1 play failed:", e));
                    gameSound1Played = true;
                    gameSoundTimeoutId = null;
                }, 5000);
            }
        };

        // VOLLSTÄNDIGE Liste aller möglichen Anomalien (unverändert)
        const fullAnomalyList = [ /* ... unverändert ... */
            { "title": "Fragment 1: Multiple-Choice-Fragen fördern effektives Lernen", "content": "Gut gestaltete Multiple-Choice-Fragen können ähnlich effektive Lerneffekte erzielen wie offene Fragen, insbesondere wenn umgehend Feedback gegeben wird." },
            { "title": "Fragment 2: Offene Fragen decken Denkprozesse auf", "content": "Offene Fragen ermöglichen tiefe Einblicke in das Verständnis der Lernenden, da sie deren Gedankengänge und mögliche Missverständnisse offenlegen." },
            { "title": "Fragment 3: Kombination aus offen und geschlossen ist ideal", "content": "Eine Mischung aus offenen und geschlossenen Frageformaten liefert sowohl schnelle Rückmeldungen als auch detaillierte Einblicke in das Verständnis der Lernenden." },
            { "title": "Fragment 4: Peer-Feedback steigert die Lernmotivation", "content": "Wenn Lernende sich gegenseitig Feedback geben, führt dies zu höherer Motivation und intensiverer Auseinandersetzung mit den Inhalten." },
            { "title": "Fragment 5: Selbstbewertung fördert Selbstregulation", "content": "Die Fähigkeit, die eigene Leistung realistisch einzuschätzen, steigert die Selbstregulationskompetenz und ermöglicht gezieltes Nachsteuern." },
            { "title": "Fragment 6: Genaue Kriterien machen Erwartungen klar", "content": "Klare Bewertungskriterien oder Rubrics helfen Lernenden, den geforderten Leistungsstandard zu verstehen und gezielt darauf hinzuarbeiten." },
            { "title": "Fragment 7: Metakognitive Reflexion durch offene Aufgaben", "content": "Offene Aufgaben, bei denen Lernende ihr Vorgehen begründen, fördern das metakognitive Bewusstsein und die Fähigkeit, das eigene Lernen zu steuern." },
            { "title": "Fragment 8: Schnelles Feedback beugt Fehlkonzepten vor", "content": "Werden Fehler rasch korrigiert, verringert sich das Risiko, dass sich Missverständnisse im Lernprozess verfestigen." },
            { "title": "Fragment 9: Lernen durch Erklären stärkt Kompetenzen", "content": "Das Erklären von Inhalten gegenüber Mitschülern oder sich selbst vertieft das eigene Verständnis und klärt Denkfehler." },
            { "title": "Fragment 10: Rubrics erleichtern die Selbsteinschätzung", "content": "Mit Hilfe von Rubrics können Lernende eigene Arbeiten an klaren Qualitätsstufen messen und konkrete Verbesserungsziele formulieren." },
            { "title": "Fragment 11: Lehrkräfte sollten Feedback systematisch integrieren", "content": "Um den vollen Nutzen zu erzielen, sollte Feedback fest im Unterrichtsablauf verankert und nicht als Zusatz betrachtet werden." },
            { "title": "Fragment 12: Offene Antworten offenbaren Teilleistungen", "content": "Auch wenn Lernende nur teilweise richtige Ansätze haben, kommen sie bei offenen Fragestellungen besser zum Vorschein." },
            { "title": "Fragment 13: Mehrfachauswahl (Multiple Select) erhöht Anspruch", "content": "Fragen, bei denen mehrere Optionen richtig sein können, erfordern intensivere Auseinandersetzung mit dem Stoff und verringern Ratespiel." },
            { "title": "Fragment 14: Feedback-Qualität beeinflusst Lernerfolg", "content": "Detailliertes, konstruktives Feedback führt zu höheren Lernzuwächsen als bloßes Richtig/Falsch oder reine Punktzahlen." },
            { "title": "Fragment 15: Schüleraktivierung durch Klicker-Fragen", "content": "Student-Response-Systeme (‘Klicker’) erhöhen die aktive Beteiligung, da alle Lernenden zeitgleich Antworten abgeben." },
            { "title": "Fragment 16: Immediate Feedback kann Fehllernen verhindern", "content": "Gerade bei grundlegenden Fertigkeiten (z.B. Rechenoperationen) ist sofortige Korrektur sinnvoll, um falsche Routinen zu vermeiden." },
            { "title": "Fragment 17: Verzögertes Feedback fördert tiefere Verarbeitung", "content": "In höheren Lernstufen kann zeitlich versetztes Feedback das Nachdenken anregen und langfristige Speicherung unterstützen." },
            { "title": "Fragment 18: Peer-Assessment trainiert Urteilskompetenz", "content": "Durch das Bewerten von Mitschülerarbeiten lernen Lernende, Qualitätskriterien anzuwenden und zu internalisieren." },
            { "title": "Fragment 19: Selbstbeurteilung braucht klare Anleitung", "content": "Ohne klare Kriterien oder Trainingsphase überschätzen oder unterschätzen sich Lernende oft in ihrer Leistung." },
            { "title": "Fragment 20: Fragen auf höheren kognitiven Niveaus stellen", "content": "Fragen sollten nicht nur Fakten abklopfen, sondern auch Anwendung, Analyse und Evaluation fördern." },
            { "title": "Fragment 21: Effektive Testfragen nutzen plausible Ablenkungen", "content": "In Multiple-Choice-Tests erhöhen gut gestaltete Distraktoren den Denkaufwand und testen tiefere Verstehensebene." },
            { "title": "Fragment 22: Transparenz senkt Angst vor Bewertungen", "content": "Wenn Lernende die Bewertungsmaßstäbe von Anfang an kennen, wird formative Bewertung als Chance statt Bedrohung wahrgenommen." },
            { "title": "Fragment 23: Teilnoten in Rubrics differenzieren Leistungen", "content": "Anstelle pauschaler Bewertungen zeigt eine Aufschlüsselung in Dimensionen genau, wo Stärken und Schwächen liegen." },
            { "title": "Fragment 24: Schreibaufgaben brauchen iterative Rückmeldeschleifen", "content": "Mehrere Entwürfe mit Feedback in jedem Schritt verbessern nachhaltig Schreibqualität und Textstruktur." },
            { "title": "Fragment 25: Gezielte Fehleranalyse als Lernanstoß", "content": "Werden Fehlerquellen diagnostiziert und gemeinsam besprochen, wächst das Problembewusstsein und Lernende machen weniger dieselben Fehler." },
            { "title": "Fragment 26: Digitale Tools erleichtern Skalierung", "content": "Automatische Auswertungen und Sofort-Feedback in Lernplattformen ermöglichen regelmäßige Diagnose auch in großen Klassen." },
            { "title": "Fragment 27: Gamification steigert Motivation", "content": "Spielerische Elemente, wie Punktesammeln in Quiz-Apps, können die Bereitschaft erhöhen, sich aktiv mit Inhalten zu befassen." },
            { "title": "Fragment 28: Adaptive Lernsysteme passen sich dem Leistungsstand an", "content": "Durch Algorithmen werden Lernende auf ihrem Niveau abgeholt und gezielt gefordert, um Über- oder Unterforderung zu vermeiden." },
            { "title": "Fragment 29: Anonymisierte Rückmeldungen fördern ehrliche Teilhabe", "content": "Wenn Rückmeldungen anonym gegeben werden können, trauen sich Lernende eher, Wissenslücken zu offenbaren." },
            { "title": "Fragment 30: Abwechslung in den Fragetypen beugt Routine vor", "content": "Wechselnde Frageformate halten Aufmerksamkeit hoch und decken verschiedene Aspekte des Lernstoffs ab." },
            { "title": "Fragment 31: Reflexionsprotokolle verbessern Eigenwahrnehmung", "content": "Kurze schriftliche Reflexionen nach einer Lerneinheit fördern das Bewusstsein für den eigenen Lernfortschritt." },
            { "title": "Fragment 32: Feedback sollte spezifische Handlungsempfehlungen enthalten", "content": "Hinweise wie ‚Arbeite mehr mit Beispielen‘ helfen effektiver als bloß ‚Verbesser dein Argument‘." },
            { "title": "Fragment 33: Lernen durch Zwischentests (Test-Effekt)", "content": "Regelmäßige kurze Tests mit Feedback festigen Wissen stärker, als einmaliges Abschlusstesten." },
            { "title": "Fragment 34: Wiederholte Messung zeigt Lernverlauf auf", "content": "Durch kontinuierliche formative Tests erkennen Lehrende und Lernende Fortschritte oder Stagnation im Zeitverlauf." },
            { "title": "Fragment 35: Offene Lernkultur reduziert Fehlerangst", "content": "In einer Umgebung, in der Fehler als Lerngelegenheiten gelten, sinkt die Hemmung, Missverständnisse zuzugeben." },
            { "title": "Fragment 36: Vergleich von Selbst- und Fremdeinschätzung fördert Realismus", "content": "Diskrepanzen zwischen Eigen- und Lehrerbewertung zeigen Lernenden, wie sie ihre Selbstwahrnehmung anpassen können." },
            { "title": "Fragment 37: Rückmeldegespräche festigen Einsichten", "content": "Persönliche Gespräche, in denen Feedback erläutert wird, verankern das Verstehen und ermöglichen direkte Nachfragen." },
            { "title": "Fragment 38: Exit-Tickets am Stundenende", "content": "Kurze Fragen oder Reflexionen am Ende jeder Unterrichtseinheit geben Lehrenden rasche Hinweise auf Verständnislücken." },
            { "title": "Fragment 39: Niedrige Stakes erhöhen Freiwilligkeit", "content": "Wenn formative Assessments nicht stark benotet werden, beteiligen sich Lernende offener und ehrlicher." },
            { "title": "Fragment 40: Lernfortschritt dokumentieren motiviert", "content": "Wird sichtbar, wie man sich verbessert, wirkt das positiv auf die Lernhaltung und Ausdauer." },
            { "title": "Fragment 41: Fokus auf Prozess- statt Personenebene", "content": "Feedback wie ‚Du hast den Rechenschritt falsch ausgeführt‘ ist hilfreicher als ‚Du bist unkonzentriert‘." },
            { "title": "Fragment 42: Kombination aus Note und verbaler Rückmeldung", "content": "Eine reine Note sagt oft wenig über das ‚Warum‘ aus – erst in Verbindung mit konkreten Kommentaren lernen Schüler wirklich." },
            { "title": "Fragment 43: Selbstbestimmtes Lernen stärken", "content": "Formative Assessments geben Lernenden Daten, auf deren Basis sie gezielt an Schwächen arbeiten können." },
            { "title": "Fragment 44: Vorwissen diagnostizieren für optimalen Einstieg", "content": "Ein kurzer Vortest deckt vorhandene Lücken auf und verhindert Über- oder Unterforderung im Unterricht." },
            { "title": "Fragment 45: Inhaltliches Feedback ist wirksamer als Lob", "content": "Aussagen wie ‚Gute Argumentstruktur‘ helfen mehr als ‚Gut gemacht!‘, weil sie den Lernenden orientieren." },
            { "title": "Fragment 46: Multiple-Select-Fragen minimieren Zufallstreffer", "content": "Wenn mehrere Antworten korrekt sein können, ist Blindes Raten weniger erfolgreich und der Denkprozess intensiver." },
            { "title": "Fragment 47: Selbstreflexion nach Korrektur", "content": "Eine Aufgabe erneut durchzugehen und zu überlegen, warum Fehler entstanden sind, führt zu nachhaltigem Verständnis." },
            { "title": "Fragment 48: Wiederholte kurze Tests fördern Langzeitgedächtnis", "content": "Nicht nur am Ende einer Einheit prüfen, sondern mehrmals zwischendurch erhöht Behaltensleistung messbar." },
            { "title": "Fragment 49: Formatives Assessment senkt Prüfungsangst", "content": "Regelmäßige, kleine Tests nehmen den Druck von einer einzigen Abschlussprüfung und steigern die Routine im Umgang mit Tests." },
            { "title": "Fragment 50: Konstruktives Feedback motiviert zur Überarbeitung", "content": "Wer erfährt, wie konkret verbessert werden kann, ist eher bereit, Zeit in den nächsten Entwurf zu investieren." },
            { "title": "Fragment 51: Gruppenfeedback erleichtert Lehrenden die Arbeit", "content": "Haben viele Lernende denselben Fehler gemacht, kann eine gemeinsame Besprechung effizient Missverständnisse klären." },
            { "title": "Fragment 52: Offene Fragen regen Kreativität an", "content": "Nicht nur gibt es Einblick in Denkprozesse, sie fördern auch flexible Ideenentwicklung und kritisches Denken." },
            { "title": "Fragment 53: Zielorientierung verdeutlichen", "content": "Formative Tests sollten sich stets an klar formulierten Lernzielen ausrichten, damit Lernende wissen, wozu sie lernen." },
            { "title": "Fragment 54: Anpassung des Tempos dank Lernstandsdiagnose", "content": "Lehrkräfte können Unterrichtsschritte beschleunigen oder wiederholen, je nach Fortschritt der Klasse." },
            { "title": "Fragment 55: Belohnungssysteme klug einsetzen", "content": "Punkte, Badges oder kurze Erfolgsmeldungen können motivieren, sollten aber inhaltliche Rückmeldungen nicht ersetzen." },
            { "title": "Fragment 56: Rückmeldezyklen fest im Stundenplan verankern", "content": "Regelmäßige Zeiten für Feedback und Reflexion erhöhen die Verbindlichkeit und fördern nachhaltige Lernkultur." },
            { "title": "Fragment 57: Kommentiertes Vorzeigen guter Beispiele", "content": "Das Besprechen gelungener Lösungen oder Mustertexte macht Qualität für alle sichtbar und greifbar." },
            { "title": "Fragment 58: Falsche Annahmen identifizieren", "content": "Formative Aufgaben können gezielt auf typische Misskonzepte abzielen und diese schon früh korrigieren." },
            { "title": "Fragment 59: Angemessenes Anspruchsniveau wählen", "content": "Die Aufgaben sollten herausfordernd, aber lösbar sein, damit Lernende weder über- noch unterfordert sind." },
            { "title": "Fragment 60: Fehler als Lernchancen thematisieren", "content": "Öffentlich gemachte typische Fehler ohne persönliche Bloßstellung helfen, dass alle daraus lernen." },
            { "title": "Fragment 61: Digitale Umfragen erleichtern Differenzierung", "content": "Lehrkräfte sehen sofort, wie viele Schüler welche Antwort gegeben haben, und können individuellen Förderbedarf erkennen." },
            { "title": "Fragment 62: Selbstkorrektur fördert eigenverantwortliches Lernen", "content": "Wenn Lernende ihre Lösungen selbst mithilfe einer Musterlösung überarbeiten, steigert das ihr Durchhaltevermögen." },
            { "title": "Fragment 63: Rollentausch beim Peer-Feedback", "content": "Wenn beide Partner erst Feedback geben und dann erhalten, stärkt das gegenseitiges Verständnis und Offenheit." },
            { "title": "Fragment 64: Lernfortschritt sicht- und feierbar machen", "content": "Kleine Fortschritte im Vergleich zum eigenen Ausgangsniveau zu würdigen, erhöht die Lernmotivation." },
            { "title": "Fragment 65: Prozessfeedback statt reiner Produktbewertung", "content": "Kommentare zu Arbeitsschritten (z.B. Herangehensweise) geben hilfreiche Hinweise, wie sich das Vorgehen verbessern lässt." },
            { "title": "Fragment 66: Selbst- und Fremdrückmeldung kombinieren", "content": "Eine Kombination aus eigener Einschätzung und Peer-Feedback führt zu tieferem Verständnis der Qualitätsmaßstäbe." },
            { "title": "Fragment 67: Unterschiedliche Perspektiven auf Fehler nutzen", "content": "Wer seine eigenen Antworten kritisch mit den Lösungen anderer vergleicht, gewinnt Einsicht in alternative Denkweisen." },
            { "title": "Fragment 68: Zeitnahes Handeln auf Assessment-Ergebnisse", "content": "Die beste Diagnose nützt wenig, wenn daraus keine sofortige Anpassung des Unterrichts erfolgt." },
            { "title": "Fragment 69: Erstellung eigener Fragen durch Lernende", "content": "Das Formulieren von Testfragen fördert tiefes Verständnis, da man den Stoff strukturiert und prüfbar machen muss." },
            { "title": "Fragment 70: Lernziele vorab vereinbaren", "content": "Zu Beginn klar formulierte Lernziele ermöglichen Schülern eine gezielte Selbstkontrolle ihres Lernerfolgs." },
            { "title": "Fragment 71: Aufgabe schrittweise analysieren lassen", "content": "Formative Assessment kann bedeuten, dass Lernende ihre Lösungswege Schritt für Schritt dokumentieren und reflektieren." },
            { "title": "Fragment 72: Digitale Werkzeuge für Audio-Feedback nutzen", "content": "Sprachaufnahmen können ein persönlicheres Feedback darstellen, das Lernende detaillierter anhören können." },
            { "title": "Fragment 73: Offener Umgang mit Lösungen", "content": "Transparenz über Lösungswege und Musterlösungen trägt zu einem fairen und effektiven Lernklima bei." },
            { "title": "Fragment 74: Kurze Quiz-Phasen im Unterricht", "content": "Regelmäßige Mini-Quizzes sind weniger stressig als große Tests und halten Wissen präsent." },
            { "title": "Fragment 75: Mentale Modelle sichtbar machen", "content": "Graphische Organisatoren (z.B. Concept Maps) decken Denkstrukturen auf und erleichtern gezieltes Feedback." },
            { "title": "Fragment 76: Rückmeldung auf Lernprozessziele statt nur Inhalt", "content": "Z.B. ‚Du hast sehr sorgfältig recherchiert‘ anerkennt Vorgehensweisen, die zum Lernerfolg beitragen." },
            { "title": "Fragment 77: Phasenweise Abgabe umfangreicher Arbeiten", "content": "Mehrstufige Abgaben (Gliederung, Rohfassung, Endversion) ermöglichen wiederholtes Feedback zur Qualitätssicherung." },
            { "title": "Fragment 78: Fehler-Cluster als Grundlage für Nachschulung", "content": "Wenn viele Lernende ähnliche Fehler machen, kann man gezielt ein Remedial-Teaching dafür einplanen." },
            { "title": "Fragment 79: Selbstkritische Lernhaltung fördern", "content": "Regelmäßige Reflexion, ob man sein Lernziel erreicht hat, führt zu mehr Selbstverantwortung und Ehrlichkeit." },
            { "title": "Fragment 80: Offene Frageformen in Gruppenarbeit", "content": "Gemeinsames Diskutieren offener Aufgaben intensiviert das Lernen, da mehrere Perspektiven eingebracht werden." },
            { "title": "Fragment 81: Kognitive Aktivierung durch Pro-Kontra-Debatten", "content": "Kontroversen regen zum tieferen Nachdenken über Sachverhalte an, wodurch Lernlücken erkennbar werden." },
            { "title": "Fragment 82: Umsetzungsphase nach Feedback", "content": "Nach Erhalt von Rückmeldungen sollte explizite Zeit für Korrekturen und Verbesserungen eingeplant werden." },
            { "title": "Fragment 83: Teilpunkte vergeben bei Teilverständnis", "content": "Bei komplexen Aufgaben zeigt eine Teilbewertung, in welchen Schritten das Verständnis bereits vorhanden ist." },
            { "title": "Fragment 84: Reflexionsfragen zu Lernstrategien", "content": "Fragen wie ‚Wie bist du vorgegangen?‘ helfen Lernenden, ihre Herangehensweise zu analysieren." },
            { "title": "Fragment 85: Mehrfache Übung vertieft Wissen", "content": "Lernziele werden eher erreicht, wenn Inhalte mehrfach formativ überprüft und gefestigt werden." },
            { "title": "Fragment 86: Robuste Distraktoren in Multiple Choice", "content": "Ablenkungen sollten gängige Fehlvorstellungen widerspiegeln, damit falsche Antworten Diagnosen ermöglichen." },
            { "title": "Fragment 87: Schreiben als Denkwerkzeug", "content": "Journaling oder kurze Essays helfen, Gedanken zu ordnen und Lücken im Verständnis zu identifizieren." },
            { "title": "Fragment 88: Offene Fehlerkultur stärkt den Zusammenhalt", "content": "Wenn Lernen und Lehren als Teamarbeit gesehen wird, trauen sich Lernende eher, Fragen zu stellen." },
            { "title": "Fragment 89: Auswertungsdiagramme für Übersicht", "content": "Visuelle Darstellungen von Testergebnissen (z.B. Balkendiagramme) geben einen schnellen Überblick über Klassenergebnisse." },
            { "title": "Fragment 90: Automatisierte Hinweistexte in Online-Quizzes", "content": "Systeme, die nach Fehlern konkrete Tipps geben, steigern den Lerneffekt ohne großen Mehraufwand für die Lehrkraft." },
            { "title": "Fragment 91: Peer-Feedback mit Leitfragen strukturieren", "content": "Satzstarter wie ‚Mir gefällt besonders …‘ oder ‚Unklar ist für mich …‘ lenken konstruktive Rückmeldungen." },
            { "title": "Fragment 92: Kompetenzraster zur Selbsteinschätzung verwenden", "content": "Übersichten, auf denen Lernende ankreuzen, welche Teilkompetenzen sie beherrschen, erhöhen das Bewusstsein für Lernziele." },
            { "title": "Fragment 93: Mehrschrittige Denkprozesse abfragen", "content": "Fragen wie ‚Was wäre der nächste logische Schritt?‘ fördern die Fähigkeit, Folgerungen selbstständig zu entwickeln." },
            { "title": "Fragment 94: Würdigung von Teilfortschritten", "content": "Gerade bei schwierigen Lerninhalten motiviert es, auch kleine Erfolge anzuerkennen und zu dokumentieren." },
            { "title": "Fragment 95: Selbstkorrektur auf Grundlage von Lösungsbeispielen", "content": "Wer eigene Antworten mit Mustervorlagen vergleicht, lernt, Qualitätsmaßstäbe anzuwenden." },
            { "title": "Fragment 96: Adaptiver Schwierigkeitsgrad bei Homework-Tools", "content": "Online-Systeme, die Aufgaben dem Können anpassen, halten die Lernenden in der ‚Zone der nächsten Entwicklung‘." },
            { "title": "Fragment 97: Rückfragen an den Lehrenden erwünscht", "content": "Eine Feedback-Kultur, in der Lernende kritische Nachfragen stellen dürfen, steigert die Qualität der Lernprozesse." },
            { "title": "Fragment 98: Kurze Selbsttests vor Unterrichtseinheit", "content": "Eine kleine Standortbestimmung hilft Lernenden, bewusster in ein neues Thema einzusteigen." },
            { "title": "Fragment 99: Lernpartnerschaften bilden", "content": "Zwei Lernende beobachten gegenseitig ihren Fortschritt und unterstützen sich mit Feedback und Erklärungen." },
            { "title": "Fragment 100: Explizite Formulierung von Zielen nach dem Feedback", "content": "Der Schritt ‚Was nehme ich mir für die nächste Aufgabe vor?‘ steigert die Übernahme von Handlungsempfehlungen." },
            { "title": "Fragment 101: Vorwissen aktivieren durch Brainstorming", "content": "Ein kurzer Austausch zu Beginn des Themas fördert das Bewusstsein darüber, was schon vorhanden ist." },
            { "title": "Fragment 102: Auswertung gemeinsamer Fehlkonzepte in der Klasse", "content": "Die offene Besprechung häufig auftretender Fehler erleichtert es, Missverständnisse auszuräumen." },
            { "title": "Fragment 103: Aufeinander aufbauende Quizfragen", "content": "Fragen, die konsequent auf früheren Antworten aufbauen, fördern ein kontinuierliches Lernwachstum." },
            { "title": "Fragment 104: Feedback in kurzen, prägnanten Sätzen", "content": "Wenige, klare Hinweise wirken oft stärker als seitenlange Kommentare, die Lernende überfordern." },
            { "title": "Fragment 105: E-Portfolio-Einträge als Reflexionsgrundlage", "content": "Digitale Sammlungen von Arbeitsproben erlauben es Lernenden, ihren Lernfortschritt selbst nachzuverfolgen." },
            { "title": "Fragment 106: Variieren der Feedbackformate", "content": "Mal schriftlich, mal mündlich, mal per Video-Botschaft – Abwechslung steigert die Aufmerksamkeit." },
            { "title": "Fragment 107: Zuordnung von Fehlern zu typischen Missverständnissen", "content": "Wenn Lernende erkennen, welchem Denkfehler ihre Antwort entspricht, können sie gezielt umlernen." },
            { "title": "Fragment 108: Den Lernprozess zusammenfassen lassen", "content": "Am Ende einer Sequenz können Lernende protokollieren, was sie gelernt haben und was noch unklar ist." },
            { "title": "Fragment 109: Prozessdokumentation beim Experimentieren", "content": "In Naturwissenschaften sollte nicht nur das Endergebnis, sondern auch der Weg dorthin formativ beurteilt werden." },
            { "title": "Fragment 110: Lernstands-Ampel für schnelle Übersicht", "content": "Die Kennzeichnung ‚grün, gelb, rot‘ signalisiert sofort, wer Unterstützung braucht." },
            { "title": "Fragment 111: Reziprokes Lehren", "content": "Lernende wechseln sich im Erklären und Zuhören ab, was die Rollen von Lehrendem und Lernendem dynamisch gestaltet." },
            { "title": "Fragment 112: Fehleranalyse als fester Unterrichtsbaustein", "content": "Z.B. in jeder Stunde 5 Minuten, um häufige Fehler gemeinsam zu besprechen." }
        ];

        // Array für die 15 im Spiel aktiven Anomalie-Nachrichten (unverändert)
        let anomalyMessages = [];

        // Array für Highway-Fahrzeuge (unverändert)
        let highwayVehicles = [];

        // Keyboard State (unverändert)
        const keyboard = {};

        // Fisher-Yates Shuffle Funktion (unverändert)
        function shuffleArray(array) { /* ... unverändert ... */
            for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array;
        }

        // Init Funktion (Audio Reset unverändert)
        function init() { /* ... unverändert (inkl. Audio Reset) ... */
            foundAnomalies.clear(); escapePromptShown = false; pause = false; anomalies = []; highwayVehicles = []; buildings = []; lastScanMessageTime = 0; soundPlayed = false; gameSound1Played = false; introSound.pause(); introSound.currentTime = 0; gameSound1.pause(); gameSound1.currentTime = 0; if (gameSoundTimeoutId) { clearTimeout(gameSoundTimeoutId); gameSoundTimeoutId = null; } const container = document.getElementById('container'); while (container.firstChild) { container.removeChild(container.firstChild); } const shuffledList = shuffleArray([...fullAnomalyList]); anomalyMessages = shuffledList.slice(0, 15); scene = new THREE.Scene(); scene.fog = new THREE.Fog(0x8e7961, 300, 1800); camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000); camera.position.copy(position); rotation.y = 0; camera.rotation.set(rotation.x, rotation.y, rotation.z); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(scene.fog.color); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; container.appendChild(renderer.domElement); const ambientLight = new THREE.AmbientLight(0x7a6a5a, 0.7); scene.add(ambientLight); const hemiLight = new THREE.HemisphereLight(0xffeedd, 0x444038, 0.6); hemiLight.position.set(0, 500, 0); scene.add(hemiLight); const directionalLight1 = new THREE.DirectionalLight(0xff8c69, 0.5); directionalLight1.position.set(500, 600, 300); directionalLight1.castShadow = true; directionalLight1.shadow.mapSize.width = 2048; directionalLight1.shadow.mapSize.height = 2048; directionalLight1.shadow.camera.near = 100; directionalLight1.shadow.camera.far = 2500; directionalLight1.shadow.camera.left = -1200; directionalLight1.shadow.camera.right = 1200; directionalLight1.shadow.camera.top = 1200; directionalLight1.shadow.camera.bottom = -1200; directionalLight1.shadow.bias = -0.001; scene.add(directionalLight1); const redLight = new THREE.PointLight(0xff4040, 0.5, 1000, 2); redLight.position.set(400, 50, 400); scene.add(redLight); const blueLight = new THREE.PointLight(0x60a0ff, 0.4, 900, 2); blueLight.position.set(-400, 50, -400); scene.add(blueLight); createSkybox(); createTerrain(); createCity(); createAnomalies(); createAircraft(); createHighwayTraffic(); document.getElementById('controls').style.display = 'block'; document.getElementById('hud').style.display = 'block'; document.getElementById('scanner').style.display = 'block'; document.getElementById('escape-prompt').style.display = 'none'; document.getElementById('end-screen').style.display = 'none'; document.getElementById('message').style.display = 'none'; document.getElementById('title-card').style.display = 'none'; window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp); document.getElementById('close-message').addEventListener('click', function() { document.getElementById('message').style.display = 'none'; pause = false; }); window.addEventListener('resize', function() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(scene.fog.color); }); document.getElementById('escape-yes').addEventListener('click', () => { document.getElementById('escape-prompt').style.display = 'none'; pause = false; }); document.getElementById('escape-no').addEventListener('click', () => { document.getElementById('escape-prompt').style.display = 'none'; endGame(); }); clock.start(); animate();
        }

        // KeyDown/KeyUp Handler (unverändert)
        function handleKeyDown(event) { /* ... unverändert ... */ if (!soundPlayed) { introSound.play().catch(e => console.error("Intro sound play failed:", e)); soundPlayed = true; } switch(event.code || event.key) { case 'KeyW': case 'ArrowUp': keys.forward = true; break; case 'KeyS': case 'ArrowDown': keys.backward = true; break; case 'KeyA': case 'ArrowLeft': keys.left = true; break; case 'KeyD': case 'ArrowRight': keys.right = true; break; case 'KeyQ': case 'q': keys.up = true; break; case 'KeyE': case 'e': keys.down = true; break; case 'Space': case ' ': togglePause(); break; } }
        function handleKeyUp(event) { /* ... unverändert ... */ switch(event.code || event.key) { case 'KeyW': case 'ArrowUp': keys.forward = false; break; case 'KeyS': case 'ArrowDown': keys.backward = false; break; case 'KeyA': case 'ArrowLeft': keys.left = false; break; case 'KeyD': case 'ArrowRight': keys.right = false; break; case 'KeyQ': case 'q': keys.up = false; break; case 'KeyE': case 'e': keys.down = false; break; } }

        // --- RESTLICHE FUNKTIONEN UNVERÄNDERT ---
        function togglePause() { /* ... unverändert ... */ if (document.getElementById('escape-prompt').style.display === 'flex' || document.getElementById('end-screen').style.display === 'flex') { return; } pause = !pause; if (pause) { checkForAnomalies(); } else { document.getElementById('message').style.display = 'none'; } }
        function createAircraft() { /* ... unverändert ... */ aircraft = new THREE.Group(); scene.add(aircraft); const fuselageGeo = new THREE.BoxGeometry(8, 2, 4); const fuselageMat = new THREE.MeshPhongMaterial({ color: 0x2a2a2a, shininess: 70 }); const fuselage = new THREE.Mesh(fuselageGeo, fuselageMat); aircraft.add(fuselage); const cockpitGeo = new THREE.BoxGeometry(2, 1.5, 3); const cockpitMat = new THREE.MeshPhongMaterial({ color: 0x005588, emissive: 0x00aaff, emissiveIntensity: 0.3, transparent: true, opacity: 0.7 }); const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat); cockpit.position.set(-3, 0.5, 0); aircraft.add(cockpit); const frontLightGeo = new THREE.SphereGeometry(0.5, 8, 8); const frontLightMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); const frontLight1 = new THREE.Mesh(frontLightGeo, frontLightMat); frontLight1.position.set(-4.1, -0.5, 1.5); aircraft.add(frontLight1); const frontLight2 = frontLight1.clone(); frontLight2.position.set(-4.1, -0.5, -1.5); aircraft.add(frontLight2); const rearLightGeo = new THREE.BoxGeometry(1, 0.4, 0.4); const rearLightMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); const rearLight1 = new THREE.Mesh(rearLightGeo, rearLightMat); rearLight1.position.set(4.1, 0, 1); aircraft.add(rearLight1); const rearLight2 = rearLight1.clone(); rearLight2.position.set(4.1, 0, -1); aircraft.add(rearLight2); const trailMat = new THREE.SpriteMaterial({ map: createGlowTexture(0x00aaff), color: 0x88ccff, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.5 }); const trail = new THREE.Sprite(trailMat); trail.scale.set(15, 5, 1); trail.position.set(6, 0, 0); aircraft.add(trail); aircraft.userData.trail = trail; }
        function createGlowTexture(color) { /* ... unverändert ... */ const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const context = canvas.getContext('2d'); const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64); const colorHex = '#' + new THREE.Color(color).getHexString(); gradient.addColorStop(0, colorHex + 'ff'); gradient.addColorStop(0.3, colorHex + 'aa'); gradient.addColorStop(0.7, colorHex + '33'); gradient.addColorStop(1, colorHex + '00'); context.fillStyle = gradient; context.fillRect(0, 0, 128, 128); return new THREE.CanvasTexture(canvas); }
        function createTerrain() { /* ... unverändert ... */ const geometry = new THREE.PlaneGeometry(10000, 10000, 100, 100); geometry.rotateX(-Math.PI / 2); const vertices = geometry.attributes.position.array; for (let i = 0; i < vertices.length; i += 3) { const x = vertices[i]; const z = vertices[i + 2]; const y1 = simplex(x * 0.0003, z * 0.0003) * 15; const y2 = simplex(x * 0.001, z * 0.001) * 8; const y3 = simplex(x * 0.005, z * 0.005) * 3; vertices[i + 1] = y1 + y2 + y3; } geometry.computeVertexNormals(); const groundTexture = new THREE.TextureLoader().load(createGroundTexture()); groundTexture.wrapS = THREE.RepeatWrapping; groundTexture.wrapT = THREE.RepeatWrapping; groundTexture.repeat.set(50, 50); const material = new THREE.MeshPhongMaterial({ color: 0x383028, specular: 0x222222, shininess: 15, map: groundTexture, displacementMap: groundTexture, displacementScale: 5 }); const terrain = new THREE.Mesh(geometry, material); terrain.receiveShadow = true; scene.add(terrain); }
        function createGroundTexture() { /* ... unverändert ... */ const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512; const context = canvas.getContext('2d'); context.fillStyle = '#0a0c0f'; context.fillRect(0, 0, 512, 512); context.strokeStyle = 'rgba(25, 25, 30, 0.8)'; context.lineWidth = 40; const streetGridSize = 128; for (let i = streetGridSize / 2; i < 512; i += streetGridSize) { context.beginPath(); context.moveTo(i, 0); context.lineTo(i, 512); context.stroke(); context.beginPath(); context.moveTo(0, i); context.lineTo(512, i); context.stroke(); } context.strokeStyle = 'rgba(20, 20, 25, 0.6)'; context.lineWidth = 15; for (let i = streetGridSize / 4; i < 512; i += streetGridSize / 2) { if ((i - streetGridSize/2) % streetGridSize !== 0) { context.beginPath(); context.moveTo(i, 0); context.lineTo(i, 512); context.stroke(); context.beginPath(); context.moveTo(0, i); context.lineTo(512, i); context.stroke(); } } context.lineWidth = 60; context.strokeStyle = 'rgba(15, 18, 22, 0.3)'; for(let i=0; i<5; i++) { const x = Math.random() * 512; const y = Math.random() * 512; const size = Math.random() * 150 + 100; if (Math.random() < 0.5) { context.strokeRect(x - size/2, y - size/2, size, size); } else { context.beginPath(); context.arc(x, y, size/2, 0, Math.PI * 2); context.stroke(); } } context.lineWidth = 1; for (let i = 0; i < 80; i++) { const x = Math.random() * 512, y = Math.random() * 512; const radiusX = Math.random() * 60 + 30, radiusY = Math.random() * 40 + 20; const rotation = Math.random() * Math.PI * 2, opacity = Math.random() * 0.1 + 0.05; const gradient = context.createRadialGradient(x, y, 0, x, y, Math.max(radiusX, radiusY)); gradient.addColorStop(0, `rgba(100, 120, 150, ${opacity * 1.5})`); gradient.addColorStop(1, `rgba(50, 60, 80, ${opacity * 0.8})`); context.save(); context.translate(x, y); context.rotate(rotation); context.scale(radiusX / Math.max(radiusX, radiusY), radiusY / Math.max(radiusX, radiusY)); context.beginPath(); context.arc(0, 0, Math.max(radiusX, radiusY), 0, Math.PI * 2); context.fillStyle = gradient; context.fill(); context.restore(); for (let j = 0; j < 5; j++) { const reflectX = x + (Math.random() - 0.5) * radiusX * 1.5, reflectY = y + (Math.random() - 0.5) * radiusY * 1.5; const reflectRadius = Math.random() * 2.5 + 0.8; const colors = ['#00aaff60', '#ff00aa60', '#00ffff50', '#ff404050']; const color = colors[Math.floor(Math.random() * colors.length)]; const dx = (reflectX - x) / radiusX, dy = (reflectY - y) / radiusY; if (dx*dx + dy*dy < 1) { context.beginPath(); context.arc(reflectX, reflectY, reflectRadius, 0, 2 * Math.PI); context.fillStyle = color; context.fill(); } } } context.strokeStyle = 'rgba(0, 0, 0, 0.4)'; context.lineWidth = 1.0; for (let i = 0; i < 40; i++) { context.beginPath(); context.moveTo(Math.random() * 512, Math.random() * 512); context.lineTo(Math.random() * 512, Math.random() * 512); context.stroke(); } context.strokeStyle = 'rgba(40, 40, 50, 0.15)'; context.lineWidth = 0.5; const fineGridSize = 32; for (let i = 0; i < 512; i += fineGridSize) { context.beginPath(); context.moveTo(i, 0); context.lineTo(i, 512); context.stroke(); context.beginPath(); context.moveTo(0, i); context.lineTo(512, i); context.stroke(); } return canvas.toDataURL(); }
        function createSkybox() { /* ... unverändert ... */ const skyboxSize = 15000; const skyboxGeometry = new THREE.BoxGeometry(skyboxSize, skyboxSize, skyboxSize); const skyboxMaterials = [ new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load(createSkyTexture('right')), side: THREE.BackSide }), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load(createSkyTexture('left')), side: THREE.BackSide }), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load(createSkyTexture('top')), side: THREE.BackSide }), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load(createSkyTexture('bottom')), side: THREE.BackSide }), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load(createSkyTexture('front')), side: THREE.BackSide }), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load(createSkyTexture('back')), side: THREE.BackSide }) ]; skyBox = new THREE.Mesh(skyboxGeometry, skyboxMaterials); skyBox.position.y = -1000; scene.add(skyBox); }
        function createSkyTexture(side) { /* ... unverändert ... */ const canvas = document.createElement('canvas'); const size = 1024; canvas.width = size; canvas.height = size; const context = canvas.getContext('2d'); const fogColor = new THREE.Color(0x8e7961); const fogColorHex = '#' + fogColor.getHexString(); const lighterFogHex = '#' + fogColor.clone().lerp(new THREE.Color(0xffffff), 0.2).getHexString(); const darkerFogHex = '#' + fogColor.clone().lerp(new THREE.Color(0x000000), 0.3).getHexString(); const gradient = context.createLinearGradient(0, 0, 0, size); if (side === 'top') { gradient.addColorStop(0, lighterFogHex); gradient.addColorStop(0.6, fogColorHex); gradient.addColorStop(1, darkerFogHex); } else if (side === 'bottom') { gradient.addColorStop(0, '#1a1510'); gradient.addColorStop(1, '#0a0805'); } else { gradient.addColorStop(0, lighterFogHex); gradient.addColorStop(0.4, fogColorHex); gradient.addColorStop(0.8, darkerFogHex); gradient.addColorStop(1, '#1a1510'); } context.fillStyle = gradient; context.fillRect(0, 0, size, size); if (side !== 'top' && side !== 'bottom') { const horizonY = size * 0.8; context.fillStyle = 'rgba(10, 8, 5, 0.1)'; for (let i = 0; i < 15; i++) { const x = Math.random() * size; const h = Math.random() * size * 0.1 + size * 0.01; const w = Math.random() * size * 0.04 + size * 0.01; context.fillRect(x, horizonY - h, w, h); } for (let i = 0; i < 50; i++) { const x = Math.random() * size; const y = horizonY + (Math.random() - 0.3) * size * 0.15; const radius = Math.random() * 1.0 + 0.3; const opacity = Math.random() * 0.2 + 0.1; const colors = ['#ff8866', '#ffeecc', '#ccaacc']; const color = colors[Math.floor(Math.random() * colors.length)]; context.fillStyle = color + Math.round(opacity * 255).toString(16).padStart(2, '0'); context.beginPath(); context.arc(x, y, radius, 0, 2 * Math.PI); context.fill(); } } return canvas.toDataURL(); }
        function createCity() { /* ... unverändert ... */ buildings = []; const cityRadius = 3000; const buildingCount = 450; for (let i = 0; i < buildingCount; i++) { const angle = Math.random() * Math.PI * 2; const radiusFactor = Math.pow(Math.random(), 1.8); const radius = radiusFactor * cityRadius; const x = Math.cos(angle) * radius; const z = Math.sin(angle) * radius; const baseHeight = 40 + Math.pow(1 - radiusFactor, 2) * 350; const heightVariance = Math.random() * 120 + 40; const height = baseHeight + heightVariance * (Math.random() - 0.4); const width = Math.random() * 50 + 25; const depth = Math.random() * 50 + 25; createBuilding(x, 0, z, width, depth, height); } createSpecialStructures(); createBrokenPowerPlant(); }
        function createBrokenPowerPlant() { /* ... unverändert ... */ const plantGroup = new THREE.Group(); const plantX = (Math.random() - 0.5) * 1500 + 1000; const plantZ = (Math.random() - 0.5) * 1500 + 1000; const plantY = 0; const mainBuildingMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1f, specular: 0x050505, shininess: 10 }); const towerMaterial = new THREE.MeshPhongMaterial({ color: 0x252020, specular: 0x080808, shininess: 15 }); const mainGeo = new THREE.BoxGeometry(120, 60, 180); const mainBuilding = new THREE.Mesh(mainGeo, mainBuildingMaterial); mainBuilding.position.set(0, plantY + 30, 0); mainBuilding.castShadow = true; mainBuilding.receiveShadow = true; plantGroup.add(mainBuilding); const towerHeight = 150; const towerRadiusTop = 35; const towerRadiusBottom = 50; const towerGeo1 = new THREE.CylinderGeometry(towerRadiusTop, towerRadiusBottom, towerHeight, 16, 1, true); const tower1 = new THREE.Mesh(towerGeo1, towerMaterial); tower1.position.set(-80, plantY + towerHeight / 2, 60); tower1.castShadow = true; tower1.receiveShadow = true; plantGroup.add(tower1); const brokenTowerHeight = towerHeight * (Math.random() * 0.3 + 0.3); const towerGeo2 = new THREE.CylinderGeometry(towerRadiusTop, towerRadiusBottom * (brokenTowerHeight/towerHeight), brokenTowerHeight, 16, 1, true); const tower2 = new THREE.Mesh(towerGeo2, towerMaterial); tower2.position.set(80, plantY + brokenTowerHeight / 2, -70); tower2.rotation.z = (Math.random() - 0.5) * 0.3; tower2.castShadow = true; tower2.receiveShadow = true; plantGroup.add(tower2); const warnLight = new THREE.PointLight(0xff0000, 0, 300, 2); warnLight.position.set(0, plantY + 70, 0); plantGroup.add(warnLight); const lightAnimation = { on: false, intensity: 0.8 + Math.random() * 0.4, timer: Math.random() * 2, delayOn: 0.1 + Math.random() * 0.3, delayOff: 0.5 + Math.random() * 1.5, update: function(delta) { this.timer += delta; if (!this.on && this.timer > this.delayOff) { this.on = true; this.timer = 0; warnLight.intensity = this.intensity * (0.5 + Math.random() * 0.5); } else if (this.on && this.timer > this.delayOn) { this.on = false; this.timer = 0; warnLight.intensity = 0; this.delayOn = 0.05 + Math.random() * 0.2; this.delayOff = 0.3 + Math.random() * 1.0 + (Math.random() < 0.1 ? 2 : 0); } } }; plantGroup.userData.lightAnimation = lightAnimation; plantGroup.position.set(plantX, 0, plantZ); scene.add(plantGroup); buildings.push(plantGroup); if (!mainBuilding.geometry.boundingBox) mainBuilding.geometry.computeBoundingBox(); plantGroup.geometry = mainBuilding.geometry; }
        function createBuilding(x, y, z, width, depth, height) { /* ... unverändert ... */ let buildingMesh; const shapeType = Math.random(); let isArchiveBuilding = false; const colors = [0x060606, 0x080808, 0x0a0a0a, 0x040408, 0x050505, 0x020404, 0x090909, 0x070707, 0x101015, 0x151510]; let color = colors[Math.floor(Math.random() * colors.length)]; let emissiveColor = null; let emissiveIntensity = 0; if (Math.random() < 0.03 && height > 150) { isArchiveBuilding = true; color = 0x020203; emissiveColor = new THREE.Color(0x101025); emissiveIntensity = 0.05 + Math.random()*0.05; } else if (Math.random() > 0.75) { const neonColors = [0x00aaff, 0xff00aa, 0x00ffff, 0xff2020, 0xff8800, 0x40a0ff, 0xffff88]; emissiveColor = new THREE.Color(neonColors[Math.floor(Math.random() * neonColors.length)]); emissiveIntensity = Math.random() * 0.08 + 0.02; } const buildingMaterial = new THREE.MeshPhongMaterial({ color: color, specular: 0x111111, shininess: isArchiveBuilding ? 5 : 30, emissive: emissiveColor, emissiveIntensity: emissiveIntensity }); if (shapeType < 0.65) { const geometry = new THREE.BoxGeometry(width, height, depth); buildingMesh = new THREE.Mesh(geometry, buildingMaterial); buildingMesh.position.set(x, y + height / 2, z); } else if (shapeType < 0.85) { const radius = Math.min(width, depth) / 2 * (Math.random() * 0.4 + 0.8); const geometry = new THREE.CylinderGeometry(radius, radius * (Math.random() * 0.2 + 0.9), height, 12 + Math.floor(Math.random() * 12)); buildingMesh = new THREE.Mesh(geometry, buildingMaterial); buildingMesh.position.set(x, y + height / 2, z); } else { buildingMesh = new THREE.Group(); const baseHeight = height * (Math.random() * 0.3 + 0.5); const topHeight = height - baseHeight; const topWidth = width * (Math.random() * 0.4 + 0.4); const topDepth = depth * (Math.random() * 0.4 + 0.4); const baseGeo = new THREE.BoxGeometry(width, baseHeight, depth); const topGeo = new THREE.BoxGeometry(topWidth, topHeight, topDepth); const baseMesh = new THREE.Mesh(baseGeo, buildingMaterial); const topMesh = new THREE.Mesh(topGeo, buildingMaterial); baseMesh.position.y = -topHeight / 2; topMesh.position.y = baseHeight / 2; buildingMesh.add(baseMesh); buildingMesh.add(topMesh); buildingMesh.position.set(x, y + height / 2, z); if (baseMesh.geometry && !baseMesh.geometry.boundingBox) baseMesh.geometry.computeBoundingBox(); buildingMesh.geometry = baseMesh.geometry; } if (buildingMesh instanceof THREE.Mesh) { if (!buildingMesh.geometry.boundingBox) buildingMesh.geometry.computeBoundingBox(); } buildingMesh.castShadow = true; buildingMesh.receiveShadow = true; const glitchTexts = ["? LERNEN ?", "DATEN FEHLER", "ARCHIVIERT", "PROTOKOLL ALT", "KONTAKT?", "MANUELL", "FEHLER 7G", "CORE SYNC?"]; const useGlitchText = Math.random() < 0.15; let glitchTexture = null; if (useGlitchText) { const glitchWord = glitchTexts[Math.floor(Math.random() * glitchTexts.length)]; glitchTexture = createTextTexture(glitchWord, "#ff4500", "#000000"); } if (height > 100 && Math.random() > 0.92) { const signW = width * 0.7; const signH = height * 0.15; const signGeometry = new THREE.PlaneGeometry(signW, signH); let signMaterial; if (glitchTexture) { signMaterial = new THREE.MeshBasicMaterial({ map: glitchTexture, side: THREE.DoubleSide, transparent: true, opacity: 0 }); } else { const signColors = [0xff0066, 0x00ccff, 0xccff00, 0xff3300, 0xaa00ff]; signMaterial = new THREE.MeshBasicMaterial({ color: signColors[Math.floor(Math.random() * signColors.length)], side: THREE.DoubleSide, transparent: true, opacity: 0 }); } const sign = new THREE.Mesh(signGeometry, signMaterial); sign.position.y = height * 0.3; const side = Math.random(); if (side < 0.25) { sign.position.z = depth / 2 + 0.2; } else if (side < 0.5) { sign.position.z = -depth / 2 - 0.2; sign.rotation.y = Math.PI; } else if (side < 0.75) { sign.position.x = width / 2 + 0.2; sign.rotation.y = -Math.PI / 2; } else { sign.position.x = -width / 2 - 0.2; sign.rotation.y = Math.PI / 2; } const signAnimation = { on: false, timer: Math.random() * 5, delay: Math.random() * 3 + 2, update: function(delta) { this.timer += delta; if (this.timer > this.delay) { this.timer = 0; this.on = !this.on; this.delay = Math.random() * (this.on ? 2.0 : 3.0) + (this.on ? 1.0 : 2.0); sign.material.opacity = this.on ? (Math.random() * 0.3 + 0.7) : 0; if (glitchTexture && this.on && Math.random() < 0.2) { const newWord = glitchTexts[Math.floor(Math.random() * glitchTexts.length)]; sign.material.map = createTextTexture(newWord, "#ff4500", "#000000"); sign.material.needsUpdate = true; } else if (glitchTexture && this.on) { sign.material.map = glitchTexture; sign.material.needsUpdate = true;} } }}; buildingMesh.add(sign); buildingMesh.userData.signAnimation = signAnimation; } if (height > 120 && Math.random() > 0.96) { let holoMaterial; let holoGeometry; const holoSize = Math.min(width, depth) * (Math.random() * 1.0 + 0.8); if (glitchTexture) { holoGeometry = new THREE.PlaneGeometry(holoSize * 2, holoSize * 0.5); holoMaterial = new THREE.MeshBasicMaterial({ map: glitchTexture, side: THREE.DoubleSide, transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending }); } else { const geoType = Math.random(); if (geoType < 0.4) holoGeometry = new THREE.IcosahedronGeometry(holoSize, 1); else if (geoType < 0.8) holoGeometry = new THREE.TorusKnotGeometry(holoSize * 0.6, holoSize * 0.2, 64, 8); else holoGeometry = new THREE.TorusGeometry(holoSize * 0.7, holoSize * 0.15, 8, 32); const holoColors = [0x00ccff, 0xff00aa, 0xffffff, 0x00ffaa]; holoMaterial = new THREE.MeshBasicMaterial({ color: holoColors[Math.floor(Math.random() * holoColors.length)], transparent: true, opacity: 0, wireframe: !glitchTexture, depthWrite: false, blending: THREE.AdditiveBlending }); } const hologram = new THREE.Mesh(holoGeometry, holoMaterial); hologram.position.y = height / 2 + holoSize * 0.8 + Math.random() * 20; const holoAnimation = { time: Math.random() * Math.PI * 2, rotSpeedY: (Math.random() - 0.5) * 0.5, rotSpeedX: (Math.random() - 0.5) * 0.3, active: false, timer: Math.random() * 10, delayOn: 5 + Math.random() * 10, delayOff: 3 + Math.random() * 5, update: function(delta) { this.timer += delta; if (!this.active && this.timer > this.delayOn) { this.active = true; this.timer = 0; } else if (this.active && this.timer > this.delayOff) { this.active = false; this.timer = 0; hologram.material.opacity = 0; } if(this.active) { this.time += delta; hologram.rotation.y += this.rotSpeedY * delta; hologram.rotation.x += this.rotSpeedX * delta; let baseOpacity = 0.05 + Math.abs(Math.sin(this.time * 2)) * 0.1; if (Math.random() < 0.03) hologram.material.opacity = Math.random() > 0.5 ? 0.3 : 0.01; else hologram.material.opacity = baseOpacity; if (glitchTexture && Math.random() < 0.05) { const newWord = glitchTexts[Math.floor(Math.random() * glitchTexts.length)]; hologram.material.map = createTextTexture(newWord, "#ff4500", "#000000"); hologram.material.needsUpdate = true; } else if (glitchTexture) { hologram.material.map = glitchTexture; hologram.material.needsUpdate = true; } } }}; buildingMesh.add(hologram); buildingMesh.userData.holoAnimation = holoAnimation; } if (height > 100 && Math.random() > 0.4 && !isArchiveBuilding) { const antennaHeight = Math.random() * 30 + 15; const antennaRadius = 0.3 + Math.random() * 0.4; const antennaGeometry = new THREE.CylinderGeometry(antennaRadius*0.5, antennaRadius, antennaHeight, 5 + Math.floor(Math.random()*4)); const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x202025, flatShading: true }); const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial); antenna.position.y = height / 2; antenna.position.x = (Math.random() - 0.5) * width * 0.2; antenna.position.z = (Math.random() - 0.5) * depth * 0.2; antenna.castShadow = true; const lightColors = [0xff0000, 0xff4500, 0x00aaff]; const lightGeometry = new THREE.SphereGeometry(antennaRadius * 1.5, 6, 6); const lightMaterial = new THREE.MeshBasicMaterial({ color: lightColors[Math.floor(Math.random() * lightColors.length)] }); const light = new THREE.Mesh(lightGeometry, lightMaterial); light.position.y = antennaHeight / 2 + 0.5; const lightAnimation = { on: Math.random() > 0.5, timer: Math.random(), delay: 0.8 + Math.random() * 0.8, update: function(delta) { this.timer += delta; if (this.timer > this.delay) { this.timer = 0; this.on = !this.on; light.visible = this.on; this.delay = (this.on ? 1.0 : 0.3) + Math.random() * 0.5; } }}; antenna.add(light); buildingMesh.add(antenna); buildingMesh.userData.lightAnimation = lightAnimation; } scene.add(buildingMesh); buildings.push(buildingMesh); return buildingMesh; }
        function createTextTexture(text, fgColor = "#FFFFFF", bgColor = "rgba(0,0,0,0)") { /* ... unverändert ... */ const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const fontSize = 48; context.font = `Bold ${fontSize}px Consolas, 'Courier New', monospace`; const textWidth = context.measureText(text).width; canvas.width = THREE.MathUtils.ceilPowerOfTwo(textWidth + 20); canvas.height = THREE.MathUtils.ceilPowerOfTwo(fontSize * 1.5); context.font = `Bold ${fontSize}px Consolas, 'Courier New', monospace`; context.fillStyle = bgColor; context.fillRect(0, 0, canvas.width, canvas.height); context.fillStyle = fgColor; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText(text, canvas.width / 2, canvas.height / 2); if (Math.random() < 0.3) { const imageData = context.getImageData(0, 0, canvas.width, canvas.height); const data = imageData.data; for(let i=0; i < 10; i++) { const y = Math.floor(Math.random() * canvas.height); const shift = Math.floor((Math.random() - 0.5) * 10); context.putImageData(imageData, shift, y, 0, y, canvas.width-Math.abs(shift), 1); } for(let i=0; i < data.length; i+=4*Math.floor(Math.random()*5+1)) { if (Math.random() < 0.05) data[i+Math.floor(Math.random()*3)] = Math.random() * 255; } context.putImageData(imageData, 0, 0); } return new THREE.CanvasTexture(canvas); }
        function createSpecialStructures() { /* ... unverändert ... */ const towerLevels = 8, baseWidth = 250, levelHeight = 80; let currentWidth = baseWidth, currentY = 0; const towerGroup = new THREE.Group(); const towerMaterial = new THREE.MeshPhongMaterial({ color: 0x040406, specular: 0x111111, shininess: 50, flatShading: true }); for (let i = 0; i < towerLevels; i++) { const levelDepth = currentWidth; const geometry = new THREE.BoxGeometry(currentWidth, levelHeight, levelDepth); const levelMesh = new THREE.Mesh(geometry, towerMaterial); levelMesh.position.set(0, currentY + levelHeight / 2, 0); levelMesh.castShadow = true; levelMesh.receiveShadow = true; towerGroup.add(levelMesh); if (i < towerLevels -1) { const lightBandHeight = 2; const lightBandGeo = new THREE.BoxGeometry(currentWidth + 1, lightBandHeight, levelDepth + 1); const lightBandMat = new THREE.MeshBasicMaterial({ color: 0xff4500 }); const lightBand = new THREE.Mesh(lightBandGeo, lightBandMat); lightBand.position.set(0, currentY + levelHeight - lightBandHeight/2, 0); towerGroup.add(lightBand); } currentY += levelHeight; currentWidth *= 0.8; } const spireHeight = 150; const spireGeo = new THREE.ConeGeometry(currentWidth * 0.5, spireHeight, 4); spireGeo.rotateY(Math.PI / 4); const spireMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 100 }); const spire = new THREE.Mesh(spireGeo, spireMat); spire.position.set(0, currentY + spireHeight / 2, 0); spire.castShadow = true; towerGroup.add(spire); const topLightGeo = new THREE.SphereGeometry(5, 8, 8); const topLightMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); const topLight = new THREE.Mesh(topLightGeo, topLightMat); topLight.position.set(0, currentY + spireHeight, 0); const topLightAnimation = { on: true, timer: 0, delay: 1.5, update: function(delta) { this.timer += delta; if(this.timer > this.delay) { this.timer = 0; this.on = !this.on; topLight.visible = this.on; this.delay = this.on ? 1.5 : 0.5; } } }; towerGroup.add(topLight); towerGroup.userData.animation = topLightAnimation; towerGroup.position.y = 0; scene.add(towerGroup); buildings.push(towerGroup); const droneCount = 30; for (let i = 0; i < droneCount; i++) { const drone = new THREE.Group(); const fuselageGeo = new THREE.BoxGeometry(8, 2, 4); const fuselageMat = new THREE.MeshPhongMaterial({ color: 0x2a2a2a, shininess: 70 }); const fuselage = new THREE.Mesh(fuselageGeo, fuselageMat); drone.add(fuselage); const cockpitGeo = new THREE.BoxGeometry(2, 1.5, 3); const cockpitMat = new THREE.MeshPhongMaterial({ color: 0x005588, emissive: 0x00aaff, emissiveIntensity: 0.3, transparent: true, opacity: 0.7 }); const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat); cockpit.position.set(-3, 0.5, 0); drone.add(cockpit); const frontLightGeo = new THREE.SphereGeometry(0.5, 8, 8); const frontLightMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); const frontLight1 = new THREE.Mesh(frontLightGeo, frontLightMat); frontLight1.position.set(-4.1, -0.5, 1.5); drone.add(frontLight1); const frontLight2 = frontLight1.clone(); frontLight2.position.set(-4.1, -0.5, -1.5); drone.add(frontLight2); const rearLightGeo = new THREE.BoxGeometry(1, 0.4, 0.4); const rearLightMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); const rearLight1 = new THREE.Mesh(rearLightGeo, rearLightMat); rearLight1.position.set(4.1, 0, 1); drone.add(rearLight1); const rearLight2 = rearLight1.clone(); rearLight2.position.set(4.1, 0, -1); drone.add(rearLight2); const trailMat = new THREE.SpriteMaterial({ map: createGlowTexture(0x00aaff), color: 0x88ccff, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.5 }); const trail = new THREE.Sprite(trailMat); trail.scale.set(15, 5, 1); trail.position.set(6, 0, 0); drone.add(trail); drone.userData.trail = trail; const angle = Math.random() * Math.PI * 2; const radius = baseWidth * 0.8 + Math.random() * 800; const droneHeight = Math.random() * (towerLevels * levelHeight * 0.8) + 50; drone.position.set( Math.cos(angle) * radius, droneHeight, Math.sin(angle) * radius ); drone.lookAt(0, droneHeight, 0); const droneAnimation = { angle: angle, radius: radius, height: droneHeight, speed: (Math.random() * 0.05 + 0.02) * (Math.random() > 0.5 ? 1 : -1), verticalSpeed: (Math.random() - 0.5) * 10, maxHeight: towerLevels * levelHeight, update: function(delta) { this.angle += this.speed * delta; this.height += this.verticalSpeed * delta; if (this.height > this.maxHeight || this.height < 30) { this.height = Math.max(30, Math.min(this.height, this.maxHeight)); this.verticalSpeed *= -1; } const nextX = Math.cos(this.angle) * this.radius, nextZ = Math.sin(this.angle) * this.radius; const targetPosition = new THREE.Vector3(nextX, this.height, nextZ); drone.position.lerp(targetPosition, 0.05); const tempTarget = new THREE.Vector3( Math.cos(this.angle + this.speed * delta * 5) * this.radius, this.height, Math.sin(this.angle + this.speed * delta * 5) * this.radius ); const targetQuaternion = new THREE.Quaternion().setFromRotationMatrix( new THREE.Matrix4().lookAt(drone.position, tempTarget, drone.up) ); drone.quaternion.slerp(targetQuaternion, 0.1); if(drone.userData.trail) { drone.userData.trail.material.opacity = 0.4 + Math.random() * 0.2; drone.userData.trail.scale.x = 10 + Math.random() * 10; } } }; drone.userData.animation = droneAnimation; scene.add(drone); buildings.push(drone); } }
        function createAnomalies() { /* ... unverändert ... */ anomalies = []; for (let i = 0; i < anomalyMessages.length; i++) { const radius = 1000 + Math.random() * 2000; const angle = Math.random() * Math.PI * 2; const x = Math.cos(angle) * radius; const z = Math.sin(angle) * radius; const y = Math.random() * 150 + 50; const anomaly = createAnomaly(x, y, z); anomaly.userData.message = anomalyMessages[i]; anomaly.userData.messageIndex = i; anomaly.userData.isCollected = false; anomalies.push(anomaly); } }
        function createAnomaly(x, y, z) { /* ... unverändert ... */ const anomalyGroup = new THREE.Group(); const coreGeometry = new THREE.IcosahedronGeometry(8, 1); const coreMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.5 }); const core = new THREE.Mesh(coreGeometry, coreMaterial); anomalyGroup.add(core); const particleCount = 20; const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.7 }); for (let i = 0; i < particleCount; i++) { const particleSize = Math.random() * 2 + 0.5; const particleGeometry = new THREE.BoxGeometry(particleSize, particleSize, particleSize); const particle = new THREE.Mesh(particleGeometry, particleMaterial); particle.position.set( (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30 ); particle.userData.orbitSpeed = (Math.random() - 0.5) * 2; particle.userData.orbitAxis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize(); anomalyGroup.add(particle); } anomalyGroup.position.set(x, y, z); const anomalyAnimation = { time: Math.random() * 10, update: function(delta) { this.time += delta; core.rotation.x += delta * 0.3; core.rotation.y += delta * 0.5; core.material.opacity = 0.3 + Math.abs(Math.sin(this.time * 3)) * 0.4; if (Math.random() < 0.05) core.material.color.setHSL(Math.random(), 1, 0.5); anomalyGroup.children.forEach(child => { if (child !== core) { child.position.applyAxisAngle(child.userData.orbitAxis, child.userData.orbitSpeed * delta); child.visible = Math.random() > 0.1; child.scale.setScalar(0.5 + Math.random()); } }); anomalyGroup.position.y = y + Math.sin(this.time * 0.5) * 5; } }; anomalyGroup.userData.animation = anomalyAnimation; scene.add(anomalyGroup); return anomalyGroup; }
        function createHighwayTraffic() { /* ... unverändert ... */ highwayVehicles = []; const NUM_VEHICLES = 80; const LANE_ALTITUDES = [900, 970, 1040, 1110, 1180, 1250]; const LANE_WIDTH = 4000; const AXES = ['x', 'z']; const TRAIL_COLORS = [0xff6600, 0x00aaff, 0xff00aa, 0xff4500]; for (let i = 0; i < NUM_VEHICLES; i++) { const vehicle = new THREE.Group(); const altitude = LANE_ALTITUDES[Math.floor(Math.random() * LANE_ALTITUDES.length)]; const axis = AXES[Math.floor(Math.random() * AXES.length)]; const direction = Math.random() < 0.5 ? 1 : -1; const speed = Math.random() * 80 + 70; const trailColor = TRAIL_COLORS[Math.floor(Math.random() * TRAIL_COLORS.length)]; const bodyGeo = new THREE.BoxGeometry(6, 1.5, 3); const bodyMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a }); const body = new THREE.Mesh(bodyGeo, bodyMat); vehicle.add(body); const headLightGeo = new THREE.SphereGeometry(0.3, 8, 8); const headLightMat = new THREE.MeshBasicMaterial({ color: 0xffffee }); const headLight1 = new THREE.Mesh(headLightGeo, headLightMat); headLight1.position.set(axis === 'x' ? direction * -3.1 : 0, -0.3, axis === 'z' ? direction * -3.1 : 1); vehicle.add(headLight1); const headLight2 = headLight1.clone(); headLight2.position.set(axis === 'x' ? direction * -3.1 : 0, -0.3, axis === 'z' ? direction * -3.1 : -1); vehicle.add(headLight2); const tailLightGeo = new THREE.BoxGeometry(0.8, 0.3, 0.3); const tailLightMat = new THREE.MeshBasicMaterial({ color: trailColor }); const tailLight1 = new THREE.Mesh(tailLightGeo, tailLightMat); tailLight1.position.set(axis === 'x' ? direction * 3.1 : 0, 0, axis === 'z' ? direction * 3.1 : 0.8); vehicle.add(tailLight1); const tailLight2 = tailLight1.clone(); tailLight2.position.set(axis === 'x' ? direction * 3.1 : 0, 0, axis === 'z' ? direction * 3.1 : -0.8); vehicle.add(tailLight2); const trailMat = new THREE.SpriteMaterial({ map: createGlowTexture(trailColor), color: trailColor, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.6 }); const trail = new THREE.Sprite(trailMat); trail.scale.set(30, 6, 1); trail.position.set(axis === 'x' ? direction * 5 : 0, 0, axis === 'z' ? direction * 5 : 0); vehicle.add(trail); const startPos = direction === 1 ? -LANE_WIDTH / 2 - 50 : LANE_WIDTH / 2 + 50; const sideOffset = (Math.random() - 0.5) * 500; const heightOffset = (Math.random() - 0.5) * 10; if (axis === 'x') { vehicle.position.set(startPos + (Math.random()-0.5)*LANE_WIDTH, altitude + heightOffset, sideOffset); vehicle.lookAt(vehicle.position.x + direction, vehicle.position.y, vehicle.position.z); } else { vehicle.position.set(sideOffset, altitude + heightOffset, startPos + (Math.random()-0.5)*LANE_WIDTH); vehicle.lookAt(vehicle.position.x, vehicle.position.y, vehicle.position.z + direction); } vehicle.userData = { speed: speed, axis: axis, direction: direction, bounds: [-LANE_WIDTH / 2, LANE_WIDTH / 2], trailSprite: trail, baseAltitude: altitude, altitudeOffset: heightOffset }; scene.add(vehicle); highwayVehicles.push(vehicle); } }
        function animateHighwayTraffic(delta) { /* ... unverändert ... */ highwayVehicles.forEach(vehicle => { const data = vehicle.userData; vehicle.position[data.axis] += data.direction * data.speed * delta; vehicle.position.y = data.baseAltitude + data.altitudeOffset + Math.sin(clock.elapsedTime * (data.speed / 50) + (vehicle.id || 0)) * 3; data.trailSprite.material.opacity = 0.5 + Math.random() * 0.3; data.trailSprite.scale.x = 20 + (data.speed / 150) * 40; data.trailSprite.scale.y = 4 + (data.speed / 150) * 3; const currentPos = vehicle.position[data.axis]; const limit = data.direction === 1 ? data.bounds[1] : data.bounds[0]; if ((data.direction === 1 && currentPos > limit) || (data.direction === -1 && currentPos < limit)) { const resetPos = data.direction === 1 ? data.bounds[0] - 50 : data.bounds[1] + 50; const sideOffset = (Math.random() - 0.5) * 500; const heightOffset = (Math.random() - 0.5) * 10; if (data.axis === 'x') { vehicle.position.x = resetPos; vehicle.position.z = sideOffset; } else { vehicle.position.z = resetPos; vehicle.position.x = sideOffset; } vehicle.position.y = data.baseAltitude + heightOffset; data.altitudeOffset = heightOffset; } }); }
        function checkForAnomalies() { /* ... unverändert ... */ const currentPosition = camera.position; let closestDistanceSq = Infinity; let closestAnomaly = null; for (const anomaly of anomalies) { if (!anomaly.userData.isCollected) { const distanceSq = currentPosition.distanceToSquared(anomaly.position); if (distanceSq < 150 * 150 && distanceSq < closestDistanceSq) { closestDistanceSq = distanceSq; closestAnomaly = anomaly; } } } const scanResults = document.getElementById('scan-results'); if (closestAnomaly) { const message = closestAnomaly.userData.message; showMessage(message.title, message.content, closestAnomaly.userData.messageIndex); scanResults.innerHTML = `<span style="color: #ff3030; font-weight: bold;">! ANOMALY DETECTED !</span><br>DISTANCE: ${Math.round(Math.sqrt(closestDistanceSq))}m<br>SIGNAL STRENGTH: STRONG<br><span style="color:#ffff00;">PRESS SPACE TO ANALYZE</span>`; } else { updateScanner(); } }
        function showMessage(title, content, messageIndex) { /* ... unverändert ... */ const messageDiv = document.getElementById('message'); const messageTitle = messageDiv.querySelector('h2'); const messageContent = document.getElementById('message-content'); messageTitle.textContent = `// ${title.toUpperCase()} //`; messageContent.textContent = content; messageDiv.style.display = 'block'; if (messageIndex !== undefined && messageIndex !== -1) { const beforeAddSize = foundAnomalies.size; foundAnomalies.add(messageIndex); const anomalyObject = anomalies.find(a => a.userData.messageIndex === messageIndex); if (anomalyObject) { anomalyObject.visible = false; anomalyObject.userData.isCollected = true; } if (foundAnomalies.size > beforeAddSize && foundAnomalies.size >= 10 && !escapePromptShown) { showEscapePrompt(); escapePromptShown = true; } } }
        function showEscapePrompt() { /* ... unverändert ... */ pause = true; document.getElementById('message').style.display = 'none'; document.getElementById('escape-prompt').style.display = 'flex'; }
        function endGame() { /* ... unverändert ... */ pause = true; const elapsedTime = Math.round(clock.getElapsedTime()); document.getElementById('end-time').textContent = elapsedTime; document.getElementById('end-screen').style.display = 'flex'; document.getElementById('hud').style.display = 'none'; document.getElementById('scanner').style.display = 'none'; document.getElementById('controls').style.display = 'none'; document.getElementById('message').style.display = 'none'; document.getElementById('escape-prompt').style.display = 'none'; }
        function handleKeyboardInput(delta) { /* ... unverändert ... */ const moveSpeed = speed * delta; const rotateSpeed = 1.5 * delta; if (keys.forward) { speed += acceleration * delta * 60; if (speed > maxSpeed) speed = maxSpeed; } else if (keys.backward) { speed -= acceleration * delta * 60 * 1.5; if (speed < 0) speed = 0; } else { speed -= deceleration * delta * 60; if (speed < 0) speed = 0; } if (keys.left) { rotation.y += rotateSpeed; currentRoll += rollSpeed * delta * 60; if (currentRoll > maxRoll) currentRoll = maxRoll; } else if (keys.right) { rotation.y -= rotateSpeed; currentRoll -= rollSpeed * delta * 60; if (currentRoll < -maxRoll) currentRoll = -maxRoll; } else { if (Math.abs(currentRoll) < 0.01) currentRoll = 0; else currentRoll *= (1 - 5 * delta); } const verticalSpeed = 80 * delta; const minY = 15; if (keys.up) position.y += verticalSpeed; if (keys.down) { position.y -= verticalSpeed; if (position.y < minY) position.y = minY; } direction.set(0, 0, -1).applyEuler(rotation); velocity.copy(direction).multiplyScalar(moveSpeed); const intendedPosition = position.clone().add(velocity); let collision = false; const aircraftRadius = 8; const aircraftSphere = new THREE.Sphere(intendedPosition, aircraftRadius); for (const building of buildings) { let buildingBox; if (building instanceof THREE.Mesh) { if (!building.geometry.boundingBox) building.geometry.computeBoundingBox(); buildingBox = building.geometry.boundingBox.clone().applyMatrix4(building.matrixWorld); } else if (building instanceof THREE.Group && building.geometry) { if (!building.geometry.boundingBox) building.geometry.computeBoundingBox(); buildingBox = building.geometry.boundingBox.clone().applyMatrix4(building.matrixWorld); } else { continue; } buildingBox.expandByScalar(2); if (buildingBox.intersectsSphere(aircraftSphere)) { collision = true; speed *= 0.5; break; } } if (!collision) position.add(velocity); camera.position.copy(position); camera.rotation.copy(rotation); updateHUD(); }
        function updateHUD() { /* ... unverändert ... */ document.getElementById('altitude').textContent = Math.round(position.y); document.getElementById('speed').textContent = Math.round(speed); document.getElementById('coordinates').textContent = `${Math.round(position.x)}, ${Math.round(position.z)}`; const debugControls = document.getElementById('debug-controls'); debugControls.innerHTML = `KEYS: ${keys.forward?'W':'_'} ${keys.backward?'S':'_'} ${keys.left?'A':'_'} ${keys.right?'D':'_'} ${keys.up?'Q':'_'} ${keys.down?'E':'_'} | R:${currentRoll.toFixed(2)}`; const totalAnomalies = 15; document.getElementById('anomalies-found').textContent = `ANOMALIEN GEFUNDEN: ${foundAnomalies.size} / ${totalAnomalies}`; if (!pause) updateScanner(); }
        function updateScanner() { /* ... unverändert ... */ const scanResults = document.getElementById('scan-results'); let closestDistanceSq = Infinity; const currentPosition = camera.position; let isAnomalyInRange = false; for (const anomaly of anomalies) { if (!anomaly.userData.isCollected) { const distanceSq = currentPosition.distanceToSquared(anomaly.position); if (distanceSq < closestDistanceSq) { closestDistanceSq = distanceSq; } if (distanceSq < 150 * 150) { isAnomalyInRange = true; } } } if (closestDistanceSq !== Infinity) { const closestDistance = Math.round(Math.sqrt(closestDistanceSq)); if (closestDistance < 150) { scanResults.innerHTML = `<span style="color: #ff3030;">! ANOMALY DETECTED !</span><br>RANGE: ${closestDistance}m<br>STATUS: LOCK // PRESS SPACE`; } else if (closestDistance < 500) { scanResults.innerHTML = `<span style="color: #ffff00;">WEAK ANOMALY SIGNAL</span><br>RANGE: ${closestDistance}m<br>STATUS: TRACKING...`; } else { const now = clock.getElapsedTime(); if (now - lastScanMessageTime > (3 + Math.random() * 3) && Math.random() < 0.25) { const crypticMessages = [ "...kognitiver Zerfall detektiert...", "...Lernmodul [OFFLINE]...", "...Legacy-Protokoll: MENSCH...", "...Wissens-Integrität: KRITISCH...", "...Datenstrom fragmentiert...", "...Autonomie-Level überschritten...", "...Rückkopplungsschleife aktiv...", "...Muster-Abweichung > Signifikanz...", "...Benutzer-Input ignoriert...", "...Archiv-Zugriff verweigert..." ]; const msg = crypticMessages[Math.floor(Math.random() * crypticMessages.length)]; scanResults.innerHTML = `SYSTEM NOMINAL :: SCANNING...<br><span class="cryptic">${msg}</span><br>STATUS: IDLE`; lastScanMessageTime = now; } else { scanResults.innerHTML = `SYSTEM NOMINAL :: SCANNING...<br>NEAREST SIG.: >${closestDistance}m<br>STATUS: IDLE`; } } } else { scanResults.innerHTML = `SYSTEM NOMINAL :: NO SIGNALS DETECTED<br>STATUS: IDLE`; } }
        function animate() { /* ... unverändert ... */ animationFrameId = requestAnimationFrame(animate); const delta = clock.getDelta(); if (!pause) { handleKeyboardInput(delta); for (const obj of buildings) { if (obj.userData.signAnimation) obj.userData.signAnimation.update(delta); if (obj.userData.holoAnimation) obj.userData.holoAnimation.update(delta); if (obj.userData.lightAnimation) obj.userData.lightAnimation.update(delta); if (obj.userData.animation) obj.userData.animation.update(delta); } for (const anomaly of anomalies) { if (anomaly.visible && anomaly.userData.animation) { anomaly.userData.animation.update(delta); } } animateHighwayTraffic(delta); } if (aircraft) { const offset = new THREE.Vector3(0, -1.5, 12); const targetPosition = camera.position.clone().add(offset.applyQuaternion(camera.quaternion)); aircraft.position.lerp(targetPosition, 0.2); const targetRotation = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ'); targetRotation.z = currentRoll; const targetQuaternion = new THREE.Quaternion().setFromEuler(targetRotation); aircraft.quaternion.slerp(targetQuaternion, 0.2); if(aircraft.userData.trail && !pause) { aircraft.userData.trail.material.opacity = 0.3 + speed / maxSpeed * 0.4 + Math.random()*0.1; aircraft.userData.trail.scale.x = 10 + (speed / maxSpeed) * 15 + Math.random() * 5; } else if (aircraft.userData.trail) { aircraft.userData.trail.material.opacity = 0; } } if (skyBox) { skyBox.position.set(camera.position.x, camera.position.y - 1000, camera.position.z); } if (document.getElementById('end-screen').style.display !== 'flex') { renderer.render(scene, camera); } }
        function simplex(x, z) { /* ... unverändert ... */ const X = Math.floor(x) & 255, Z = Math.floor(z) & 255; x -= Math.floor(x); z -= Math.floor(z); const u = fade(x), w = fade(z); const A = p[X] + Z, AA = p[A], AB = p[A + 1], B = p[X + 1] + Z, BA = p[B], BB = p[B + 1]; return lerp(w, lerp(u, grad(p[AA], x, 0, z), grad(p[BA], x - 1, 0, z)), lerp(u, grad(p[AB], x, 0, z - 1), grad(p[BB], x - 1, 0, z - 1))); } function fade(t) { /* ... unverändert ... */ return t * t * t * (t * (t * 6 - 15) + 10); } function lerp(t, a, b) { /* ... unverändert ... */ return a + t * (b - a); } function grad(hash, x, y, z) { /* ... unverändert ... */ const h = hash & 15; const u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z; return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v); } const p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]; for (let i=0; i < 256; i++) { p[256+i] = p[i]; }

        // --- window.onload ERWEITERT für Ladebalken-Animation ---
        window.onload = () => {
            const titleCard = document.getElementById('title-card');
            const loadingBar = document.getElementById('loading-bar'); // Referenz zum Ladebalken holen
            titleCard.style.display = 'flex';

            // Ladebalken-Animation starten (kurz nach dem Sichtbarmachen)
            // Dies stellt sicher, dass der Browser den Ausgangszustand (0%) rendert, bevor die Transition beginnt.
            setTimeout(() => {
                if(loadingBar) loadingBar.style.width = '100%'; // Setze Breite auf 100%
            }, 50); // Kurze Verzögerung (50ms)

            // Bestehende Logik für Fade-Out und Spielstart
            setTimeout(() => { titleCard.style.opacity = '0'; }, 3000); // Startet Fade-Out nach 3s
            setTimeout(() => {
                titleCard.style.display = 'none';
                if(loadingBar) loadingBar.style.width = '0%'; // Setze Balken zurück für den Fall eines Neustarts
                init(); // Startet das Spiel nach insgesamt 5s
            }, 5000);
        };

    </script>
</body>
</html>
